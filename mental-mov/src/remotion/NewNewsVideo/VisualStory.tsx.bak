import React, { useMemo } from "react";
import {
  AbsoluteFill,
  Img,
  interpolate,
  staticFile,
  useCurrentFrame,
  Easing,
} from "remotion";
import { STORY_MANIFEST } from "./storyManifest";

const SCENE_DURATION = 450; // 15 seconds
const TRANSITION_DURATION = 60; // 2 seconds overlap

// Flatten all chunks into a single list of scenes
const CHUNK_KEYS = [
  "chunk_01",
  "chunk_02",
  "chunk_03",
  "chunk_04",
  "chunk_05",
  "chunk_06",
];
const ALL_SCENES = CHUNK_KEYS.flatMap(
  (key) => STORY_MANIFEST[key] || new Array(20).fill(""),
);

interface MovingImageProps {
  src: string;
  startFrame: number;
  index: number;
}

const MovingImage: React.FC<MovingImageProps> = ({
  src,
  startFrame,
  index,
}) => {
  const frame = useCurrentFrame();
  const progress = frame - startFrame;
  const totalDuration = SCENE_DURATION + TRANSITION_DURATION; // Keep moving a bit longer for smoothness

  // Deterministic animation type based on index
  const animationType = index % 4; // 0: ZoomIn, 1: PanRight, 2: ZoomOut, 3: PanLeft

  const scale = useMemo(() => {
    const t = interpolate(progress, [0, totalDuration], [0, 1]);
    // Easing for smoother movement
    if (animationType === 0) return interpolate(t, [0, 1], [1.0, 1.15]); // Zoom In
    if (animationType === 2) return interpolate(t, [0, 1], [1.15, 1.0]); // Zoom Out
    return 1.1; // Default for pans
  }, [progress, totalDuration, animationType]);

  const translateX = useMemo(() => {
    const t = interpolate(progress, [0, totalDuration], [0, 1]);
    if (animationType === 1) return interpolate(t, [0, 1], [-20, 20]); // Pan Right
    if (animationType === 3) return interpolate(t, [0, 1], [20, -20]); // Pan Left
    return 0;
  }, [progress, totalDuration, animationType]);

  // Dissolve Logic:
  // If it's the very first image (index 0), just appear.
  // Otherwise, fade in over the previous image.
  const opacity = useMemo(() => {
    if (index === 0) return 1;
    // Fade in during the first TRANSITION_DURATION frames
    return interpolate(progress, [0, TRANSITION_DURATION], [0, 1], {
      extrapolateLeft: "clamp",
      extrapolateRight: "clamp",
    });
  }, [progress, index]);

  if (!src) return null; // Empty slot = Black

  return (
    <AbsoluteFill
      style={{
        overflow: "hidden",
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <Img
        src={staticFile(src)}
        style={{
          width: "100%",
          height: "100%",
          objectFit: "cover",
          transform: `scale(${scale}) translateX(${translateX}px)`,
          opacity: opacity,
        }}
      />
    </AbsoluteFill>
  );
};

const GrainOverlay: React.FC = () => {
  return (
    <AbsoluteFill
      style={{ pointerEvents: "none", mixBlendMode: "overlay", opacity: 0.1 }}
    >
      <svg width="100%" height="100%">
        <filter id="noiseFilter">
          <feTurbulence
            type="fractalNoise"
            baseFrequency="0.8"
            numOctaves="3"
            stitchTiles="stitch"
          />
        </filter>
        <rect width="100%" height="100%" filter="url(#noiseFilter)" />
      </svg>
    </AbsoluteFill>
  );
};

export const VisualStory: React.FC = () => {
  const frame = useCurrentFrame();

  // Calculate which scene is "active" (the one that should be on top)
  const currentSceneIndex = Math.floor(frame / SCENE_DURATION);

  // We render the current scene AND the previous scene (if current is fading in)
  // Actually, since we use "Fade Over", we effectively stack them.
  // To save performance, we only render:
  // 1. The previous scene (as background) IF we are in the transition period
  // 2. The current scene (on top)

  const isTransitioning = frame % SCENE_DURATION < TRANSITION_DURATION;

  const scenesToRender = [];

  // If transitioning, we see the previous scene behind the current one
  if (isTransitioning && currentSceneIndex > 0) {
    scenesToRender.push(currentSceneIndex - 1);
  }

  // We always render the current scene
  scenesToRender.push(currentSceneIndex);

  return (
    <AbsoluteFill style={{ backgroundColor: "black" }}>
      {scenesToRender.map((index) => {
        if (index < 0 || index >= ALL_SCENES.length) return null;
        const path = ALL_SCENES[index];
        const startFrame = index * SCENE_DURATION;

        return (
          <MovingImage
            key={`scene-${index}`}
            index={index}
            src={path}
            startFrame={startFrame}
          />
        );
      })}
      <GrainOverlay />
    </AbsoluteFill>
  );
};
